#!/usr/bin/env ruby
require 'optparse'

options = {
  :flavor => 'm1.large',
  :region => 'us-east-1'
}

@parser = OptionParser.new do |opts|
  opts.banner = <<EOL
chef_create creates a new server via knife ec2 server create

  Usage: chef_exec [options] TYPE ENV NAME
EOL

  opts.on('-n',   '--name [NAME]', "Node name to match") {|v| options[:name] = v }
  opts.on('-e',   '--environment [ENV]', "Node chef-environment to match") {|v| options[:chef_environment] = v }
  opts.on('-d',   '--data-center [DC]', "EC2 Data CEnter") {|v| options[:data_center] = v }
  opts.on('-r',   '--run-list [RUN_LIST]', "Node initial run list") {|v| options[:run_list] = v }
  opts.on('-t',   '--type [TYPE]', "Server type (ie: unicorn)") {|v| options[:type] = v }
  opts.on('-z',   '--availability_zone [AZ]', "EC2 Availability Zone") {|v| options[:az] = v }
  opts.on('-f',   '--flavor [FLAVOR]', "EC2 Instance Type (ie: m1.large)") {|v| options[:flavor] = v }
  opts.on('-s',   '--security_group [SG]', "EC2 security group") {|v| options[:security_group] = v }
  opts.on('-e',   '--region [R]', "EC2 Region") {|v| options[:region] = v }
  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end
end
@parser.parse!(ARGV)

def usage_error(error)
  puts "ERROR: #{error}\n\n"
  puts @parser
  exit 1
end

options[:name]              ||= ARGV.pop
options[:type]              ||= ARGV.shift
options[:chef_environment]  ||= ARGV.shift
options[:az]                ||= 'us-east-1c' if %w(qa staging).include? options[:chef_environment]

usage_error('server name required!') unless options[:name]
usage_error('server type required!') unless options[:type]
usage_error('chef environment required!') unless options[:chef_environment]
usage_error('availability zone required!') unless options[:az]

options[:security_group] ||= case options[:chef_environment]
  when /production/;
    case options[:type]
      when 'mongo'; 'db_servers'
      else; 'private_web'
    end
  else; 'default'
end

options[:data_center] ||= case options[:chef_environment]
  when /production/;        'davis'
  else;                     'hudson'
end

options[:run_list] ||= begin
  base_list = "role[MONITORING_DISABLED], role[#{ options[:data_center] }]"
  custom_roles = case options[:type]
    when 'unicorn';           "role[rails_server]"
    when 'rails_server';      "role[rails_server]"
    when 'resque';            "role[rails_utility]"
    when 'rails_utility';     "role[rails_utility]"
    when 'image_transcoder'; "role[image_transcoder]"
    when 'mongo';             "role[mongo], recipe[openvpn::client]"
  end
  [base_list, custom_roles, "role[base_final]"].join(', ')
end

identity_file = case options[:region]
  when 'us-east-1'
    case options[:chef_environment]
      when /production/;          '~/.ec2/katama-prod.pem'
      else;                       '~/.ec2/katama-integration.pem'
    end
  when 'us-west-1'; '~/.ec2/euphrates.pem'
end

ssh_user = ENV['KATAMA_USER'] || ENV['USER']
gateway_host = case options[:data_center]
  when 'davis';     "#{ssh_user}@login.dav.brightcove.com"
  when 'euphrates'; "#{ssh_user}@login.eup.brightcove.com"
  when 'hudson';    "#{ssh_user}@login.hud.brightcove.com"
  else;             raise 'Unconfigured data center'
end

ami_id = case options[:region]
  when 'us-east-1'; 'ami-4fa37426'
  when 'us-west-1'; 'ami-5b94ca1e'
end

ssh_key_name = case options[:region]
  when 'us-east-1'; 'katama-prod'
  when 'us-west-1'; 'west-katama-prod'
end

filters = options.keys.map {|option| "#{option}:#{options[option]}" }

cmd = "env DC=#{options[:data_center]} CHEF_ENV=#{options[:chef_environment]} knife ec2 server create -V -I #{ami_id} -E #{options[:chef_environment]} -x ubuntu -i #{identity_file} -r '#{options[:run_list]}' -N #{options[:name]} -f #{options[:flavor]} --region #{options[:region]} -Z #{options[:az]} --ssh-key #{ssh_key_name} -G #{options[:security_group]} --server-connect-attribute private_ip_address --ssh-gateway #{gateway_host}"
puts cmd
system("cd /work/chef; #{cmd}")